---
title: "Building Software Like a Builder"
slug: "build-like-a-builder"
summary: "Preconstruction mindset for solo devs using coding agents. Learn to think in specifications, acceptance criteria, and systematic iteration."
date: "2025-10-16"
updated: "2025-10-16"
tags: ["ai", "workflow", "devtools", "spec"]
cover: ""
status: "published"
series: "Preconstruction"
---

## Why Specifications Matter

When I managed $63M in construction scope across a $500M hospital campus, preconstruction was everything. Before a single foundation pour, we had:

- **Complete specs** (300+ page submittal packages)
- **Acceptance criteria** (city code, ADA, seismic, fire marshal)
- **Risk mitigation** (value engineering, bid alternates)
- **Change management** (RFIs, field directives, punch lists)

Software engineering can learn from this. A clear spec is your architectural drawing. Your coding agent is the general contractor.

<Admonition type="tip">
Rule: **SPEC leads the code**. Update the specification first, then implement.
</Admonition>

## The Preconstruction Workflow

Here's how I build features today with Claude Code:

### 1. Write the Spec

Create a developer spec in `/docs/` that answers:

- What does this feature do? (TL;DR, boundaries)
- What's the tech? (stack, new dependencies)
- What does success look like? (DoD, metrics, acceptance criteria)

<Window title="docs/BLOG_V2_SPEC.md">
```markdown
## TL;DR
Ship production blog system with MDX authoring, Zen view with j/k navigation,
Unix aesthetic shortcodes, cursor-reactive blob background.

## Success Criteria
- LCP ‚â§ 2.5s desktop
- CLS ‚â§ 0.02
- j/k/Enter/Esc navigation works
- All shortcodes render in 3 themes
```
</Window>

### 2. Break Into Milestones

Construction has phases: sitework ‚Üí foundations ‚Üí framing ‚Üí MEP ‚Üí finishes.

Software has milestones:

<Terminal cmd="tree docs/milestones">
M1_contentlayer_plumbing.md
M2_shortcodes.md
M3_zen_list_keyboard_nav.md
M4_background_blob.md
M5_cdn_wiring.md
M6_seo_feeds_og.md
M7_isr_ci_guards.md
</Terminal>

Each milestone has:
- **Tasks** (file paths, line counts)
- **DoD** (what must pass before moving on)
- **Rollback plan** (if tests fail)

### 3. Implement With Testing Gates

Submit the spec to your coding agent:

<Key>Cmd</Key> + <Key>K</Key> ‚Üí "Ingest `docs/BLOG_V2_SPEC.md` and implement M1. Run build test after."

The agent:
1. Reads the spec
2. Implements M1 tasks
3. Runs `npm run build`
4. Reports pass/fail

If ‚úÖ pass ‚Üí move to M2.
If ‚ùå fail ‚Üí agent debugs, or you adjust the spec.

## Why This Works

### Async Collaboration

Your spec is the single source of truth. The agent reads it, you review diffs, the next agent picks up where the last left off.

No "what were we doing?" moments.

### Scope Control

In construction, **scope creep kills budgets**. In software, it kills momentum.

The spec defines boundaries. If a new idea comes up mid-implementation:

1. Note it in `## Future Enhancements`
2. Finish current milestone
3. Decide if the new idea merits a new spec

<Admonition type="warn">
**Don't mix phases.** Framing crews don't install HVAC. Your M2 shortcode PR doesn't refactor routing.
</Admonition>

### Quality Gates

Every milestone ends with a test:

- M1: `npm run build` generates types
- M2: Shortcodes render in 3 themes
- M3: Keyboard nav works (manual test)
- M4: CPU <1% idle (DevTools)

If a gate fails, you don't proceed. This prevents compounding technical debt.

## Example: Blog V2

I'm shipping this blog system using the preconstruction method:

1. ‚úÖ Wrote [BLOG_V2_SPEC.md](https://github.com/example/dleer-portfolio/blob/main/docs/BLOG_V2_SPEC.md)
2. ‚úÖ Broke into M1‚ÄìM7 with DoD per milestone
3. üîÑ Implementing M3 (Zen list + keyboard nav)
4. ‚è≥ Remaining: M4‚ÄìM7

Each PR is a milestone. Each merge passes CI. No "fix later" commits.

## Tools I Use

<Figure
  src="https://images.unsplash.com/photo-1498050108023-c5249f4df085?w=1200&q=80"
  alt="Developer desk with terminal, code editor, and mechanical keyboard"
  caption="Clean dev environment: specs on the left, implementation on the right."
/>

- **Specs**: Markdown in `/docs/`
- **Agent**: Claude Code (via [claude.com/code](https://claude.com/code))
- **Quality gates**: `npm run build`, `npm run lint`, `npm run typecheck`
- **CI**: GitHub Actions (lint ‚Üí type ‚Üí build ‚Üí deploy)

## When to Skip the Spec

Not every feature needs a 300-line spec. Use judgment:

- **Need a spec**: Multi-day features, new architecture, agent handoff
- **Skip the spec**: Bug fixes, one-file changes, copy updates

If it takes <30 minutes and touches <100 LOC, just code it.

## Key Takeaways

1. **Spec first, code second** ‚Üí Prevents rework
2. **Milestone-driven** ‚Üí Ship iteratively, test at gates
3. **Acceptance criteria** ‚Üí Know when you're done
4. **Async-friendly** ‚Üí Agents/collaborators read the spec, not your mind

<Admonition type="note">
Think like a builder: Pour a solid foundation (spec), frame the structure (milestones), wire the systems (implementation), finish the surfaces (polish).
</Admonition>

## Next in Series

- **Part 2**: Designing acceptance criteria that prevent scope creep
- **Part 3**: CI/CD for solo devs (automate the punch list)

---

*Written with Claude Code using the preconstruction method.*
*Spec: [BLOG_V2_SPEC.md](https://github.com/example/dleer-portfolio/blob/main/docs/BLOG_V2_SPEC.md)*
